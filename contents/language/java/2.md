# 객체지향 핵심 원리

> 작성자 : [서그림](https://github.com/Seogeurim)

<details>
<summary>Table of Contents</summary>

- [객체 지향 핵심 개념](#객체-지향-핵심-개념)
- [객체 지향 언어의 주요 개념](#객체-지향-언어의-주요-개념)

</details>

## 객체 지향 핵심 개념

### 객체 지향 패러다임의 등장

1960년대 말, 하드웨어 발전 속도에 비해 소프트웨어 발전 속도가 느리다는 현상에 따라 '소프트웨어 위기론'이 등장하였다. 이 때 하드웨어와 소프트웨어의 특징을 비교해보면 다음과 같다.

- 하드웨어는 각 기능들이 독립적인 모듈로 개발된다.  
   여러 모듈을 조립할 수 있고, 특정 모듈이 고장나거나 성능이 떨어지면 교체 및 수정이 용이하다.
- 소프트웨어는 모듈화가 되지 않았다.  
   따라서 한 번 작성된 코드는 재사용이 어렵다는 문제점이 있었다.

이러한 분석에 따라 **모듈화된 소프트웨어 개발에 대한 요구**가 발생하였고, 이는 **객체 지향 패러다임**으로 이어졌다.

### 객체 지향 프로그래밍 (OOP, Object Oriented Programming)

객체 지향 프로그래밍이 등장하기 이전에는 **절차 지향 프로그래밍**이었다. 절차 지향 프로그래밍 언어는 **실행 순서가 위 -> 아래로 순차적으로 진행**되었고, 코드 재사용을 위해서는 기존에 만들어진 코드를 **복사 + 붙여넣기** 해야 했다.

이러한 문제점을 극복하기 위해 **함수**가 등장하였다. 함수는 **자주 사용되는 특정한 코드를 하나의 모듈(묶음)으로 묶어 놓은 것**이다. 따라서 필요할 때마다 함수를 호출해서 사용하는 방식으로 코드 재사용이 가능했지만, 데이터와 함수 간 유기적인 관계성을 갖지 못한다는 아쉬움이 있었다.

이후 **객체 지향 프로그래밍**이 등장하면서 함수보다 더 높은 모듈화를 지원하게 된다. **객체 자신이 가진 고유의 데이터를 처리하는 메서드가 등장**하게 된 것이다. 이를 통해 보다 높은 유지보수성을 가지게 되었고, 객체 간 자유로운 데이터 이동이 가능해지게 되었다.

### 객체, 클래스, 인스턴스

> 관계 : 객체 ▶︎ 클래스 ▶︎ 인스턴스

- **객체 (Object)** : 현실 세계에 존재하는 유무형의 모든 것
  - 정적인 요소 : 변수 (Variable)
  - 동적인 요소 : 메서드 (Method)
- **클래스 (Class)** : 현실 세계의 객체를 프로그램에서 이용할 수 있는 객체로 표현하는 것
  - 현실 세계의 객체를 컴퓨터 메모리에 생성할 수 있는 템플릿이라고 볼 수 있다.
  - 자바 프로그램을 구성하는 가장 기본적인 요소이다.
- **인스턴스 (Instance)** : 컴퓨터 메모리에 존재하는 객체
  - 클래스로부터 생성된 컴퓨터 메모리 상의 객체이다.
  - Object = Instance

## 객체 지향 언어의 주요 개념

### 상속 (Inheritance)

만일 기존의 클래스에 대하여 속성과 메서드가 약간 다른 객체를 필요로 한다고 생각해보자. 이 경우 **상속**을 이용하면 이미 존재하는 클래스를 바탕으로 필요한 변수, 메서드를 추가 정의하여 새로운 클래스를 작성할 수 있다.

#### 상속의 특징

- 코드의 재사용성을 높임  
  공통적 속성/기능에 대하여 수정이 필요한 경우 해당 클래스에 대해서만 수정하면 된다.
- 객체들 사이의 계층 구조를 이룰 수 있음
  - 상위 계층으로 갈수록 : 일반화, 보편화
  - 하위 계층으로 갈수록 : 특수화, 개별화
- 자식 클래스는 자신의 변수&메서드 뿐만 아니라 부모 클래스의 변수와 메서드를 모두 사용할 수 있다.
- 상속 관계는 **논리적으로** 반드시 **is a~ 관계**가 성립되어야 한다.  
   부모-자식 클래스의 관계가 일반화, 특별화 관계(is a~)에 있어야 한다. 이는 문법적으로 강제되는 것이 아니라 논리적으로 판단되어야 한다. 그렇지 않으면 유지보수가 어려워진다.

#### 상속의 종류

- 다중 상속 : 하나의 하위 클래스가 두 개 이상의 상위 클래스를 갖는 것
- 단일 상속 : 하나의 하위 클래스가 단 하나의 상위 클래스를 갖는 것

자바는 단일 상속만을 지원하는 언어이다.

### 다형성 (Polymorphism)

> one interface, multiple implementation

인터페이스는 하나지만 인터페이스의 구현체는 여러가지를 만들어 사용할 수 있다는 개념이다.

다형성은 메서드 오버로딩과 오버라이딩을 통해 지원된다.

- **오버로딩(Overloading)** : 한 클래스 안에 같은 이름의 메서드를 여러개 정의하면서, 그 인자의 개수나 유형을 다르게 해 놓은 형태
- **오버라이딩(Overriding)** : 상속 관계에 있는 하위 클래스가 상위 클래스가 가지고 있는 메서드를 재정의하는 것 (재정의된 메서드가 선언된 형태는 상위 클래스에서 선언된 것과 같음)

### 추상화 (Abstraction)

현실 세계에 존재하는 다양한 객체들의 공통된 특성을 모아 일반화 해놓는 것으로, 클래스를 정의하는 데 중요한 역할을 한다.

> ex. [비행기, 자동차, 열차, 배]는 화물이나 승객을 운반한다는 공통적 특징이 있다.  
> 따라서 **운송 수단**으로 추상화가 가능하며, 더 나아가 클래스로서 정의가 가능하다.

### 캡슐화 (Encapsulation)

변수와 메서드를 하나의 추상화된 클래스로 묶어 독립적으로 동작하지 않도록 한다. 이들은 따로 분리할 수 없다. 객체를 이용할 때는 객체가 제공하는 메서드를 통해 이용하고 데이터가 실제로 어떻게 처리되는지는 알 필요 없다.

### 정보 은닉 (Information Hiding)

캡슐화된 변수나 메서드를 선택적으로 공개하거나 숨길 수 있다는 개념이다. 숨겨야 하는 정보는 `private`, 공개하는 정보는 `public`으로 관리하며 외부에서는 `public`만 접근이 가능하다.

### 메시지 (Message)

객체들은 서로 메시지를 주고 받는 방식으로 **통신**한다.

객체 간에 메시지를 주고 받기 때문에 여러 객체는 동일한 프로세스를 가질 필요가 없으며, 서로 메시지를 주고 받는데 객체가 존재하는 위치는 제약이 되지 않는다.

#### 메시지 형식

- 메시지를 전달할 대상 객체 ex. `car`
- 전달하고 싶은 메시지 ex. `changeGear`
- 메시지를 통해 전달하고 싶은 부가정보가 있다면 해당 정보 ex. `lowerGear`

> ex. Person 객체가 Car 객체에게 낮은 기어로 변속을 요청하고 싶으면 `car.changeGear(lowerGear)`와 같은 형식으로 메시지를 전달하면 된다.

## 클래스의 구조

### 클래스의 구성 요소

#### 클래스 선언부

- 접근 제한자 (Access Modifier)
- 클래스 (Class) + 클래스명

#### 클래스 몸체

- 생성자 (Constructor)
- 멤버 변수 (Variable)
- 메서드 (Method)

> 변수와 메서드를 하나의 클래스로 묶음으로서 **캡슐화**를 구현한다.

```java
public class Employee { // 클래스 선언부
  // 멤버 변수 (Variable)
  private String name;
  private String dept;

  // 생성자 (Constructor)
  public Employee(String name, String dept) {
    this.name = name;
    this.dept = dept;
  }

  // 메서드 (Method)
  public String getName() {
    return name;
  }
  public void setName(String name) {
    this.name = name;
  }
}
```

### 클래스 Modifier

> 접근 권한과 관련된 modifier를 지정하지 않으면 같은 패키지 내의 클래스에서만 접근 가능

- 접근 권한 예약어
  - `public` : 모든 클래스에서 접근이 가능한 클래스임을 의미
- 활용 방법 예약어
  - `final` : 자식 클래스를 가질 수 없는 클래스임을 의미
  - `abstract` : 객체 생성이 불가능한 추상 클래스를 의미

### 객체 생성

#### `[객체 참조 변수 이름] = new [클래스 이름]();`

- 객체가 사용할 메모리 영역을 할당하는 과정에서 예약어 `new`를 사용한다.
- 생성된 객체에 대한 참조값(메모리 주소)을 객체 참조 변수에 할당한다.
- 하나의 클래스로부터 여러 개의 객체를 생성할 수 있다.

```java
Employee emp1 = new Employee('John', 'sales');
Employee emp2 = new Employee('Alice', 'design');
```

### 멤버 변수의 선언

- 전역(Global) 변수 : 멤버 변수라고도 칭하며, 클래스의 여러 메서드에서 공통으로 사용할 수 있다.
- 지역(Local) 변수 : 해당 변수가 선언된 메서드 내에서만 사용할 수 있다.

변수는 **modifier**를 통해 접근 권한이나 활용 방법을 제어한다. 이를 통해 객체 지향의 **정보 은닉(Information Hiding)** 개념을 구현할 수 있다.

#### 접근 권한

- public : 모든 클래스에서 접근이 가능
- (default) : 동일 패키지에 속하는 클래스에서 접근 가능
- protected : 동일 패키지에 속하는 클래스, 하위 클래스 관계의 클래스가 접근 가능
- private : 해당 클래스 내에서만 접근이 가능

#### 활용 방법

- final : 변수를 상수로 이용 (값 변경 불가)
- static : 클래스에 소속된 클래스 변수로 이용

### 메서드의 선언

메서드 구성 요소로는 **접근 제한자, 반환형, 메서드명, 매개변수**가 있다. 접근 제한자(modifier)로는 다음을 쓸 수 있다.

#### 접근 권한

> 멤버 변수와 동일

#### 활용 방법

- final : Overriding이 불가능한 메서드
- static : 클래스에 소속된 클래스 메서드
- abstract : 추상 메서드, 하위 클래스에 의해 구현
- synchronized : Thread의 동기화를 위한 메서드

메서드의 선언부인 **반환형, 메서드명, 매개변수**의 세 가지 요소를 합쳐 **메서드 시그니쳐(Signature)** 라고 한다.

### Getter/Setter 메서드를 통한 정보 은닉

대부분의 경우 멤버 변수들을 private으로 선언하고 public 메서드를 통해 접근하도록 클래스를 구성한다. 이를 통해 정보 은닉의 개념을 구현한다.

- Getter : private 멤버 변수에 저장된 값을 반환
- Setter : private 멤버 변수에 값을 저장
