# Algorithm (알고리즘)

## 알고리즘 기본 [▶︎ 🗒](basic.md)

- [시간복잡도와 공간복잡도](basic.md#시간복잡도와-공간복잡도)
- 완전 탐색 알고리즘 (Brute Force)
  - [DFS와 BFS](basic.md#dfs와-bfs)
  - [순열, 조합, 부분집합](basic.md#순열-조합-부분집합)
- 백트래킹 (Backtracking)
- 분할 정복법 (Divide and Conquer)
- 탐욕 알고리즘 (Greedy)
- 동적 계획법 (Dynamic Programming)

## 알고리즘 응용

- [정렬 알고리즘](sort.md) (Insertion / Selection / Bubble / Merge / Quick / Heap / Radix / Counting Sort)
- [그래프](graph.md)
  - [최단 경로 알고리즘](graph.md#최단-경로-알고리즘) (다익스트라, 벨만-포드, 플로이드-워셜)
  - [분리 집합(Union Find)과 크루스칼(Kruskal) 알고리즘](graph.md#분리-집합Union-Find과-크루스칼Kruskal-알고리즘)
- [두 포인터 (two-pointer)](two-pointer.md)
- [문자열 처리 알고리즘](string.md)
  - [KMP 알고리즘](string.md#문자열-패턴-매칭)

---

## 질의응답

<!-- 탐색 알고리즘 -->

<details>
<summary>질문을 작성해주세요.</summary>
<p>

답변을 작성해주세요.

</p>
</details>

---

<!-- 정렬 알고리즘 -->

<details>
<summary>라이브러리 없이 정렬을 구현하려고 할 때 어떤 정렬 방식을 사용해 구현할 것이고 왜 그렇게 생각하는지 성능 측면에서 얘기를 해주세요.</summary>
<p>

(예시 답안)
퀵소트로 구현할 것입니다. 퀵소트는 average case에서 nlgn의 시간복잡도를 가지며 공간복잡도 측면에서도 제자리 정렬이기 때문에 좋은 성능을 가집니다. worst case의 경우 n^2의 시간복잡도를 가지지만 worst case가 나타날 경우는 확률적으로 매우 낮습니다. (자료가 n개일 때 오름차순 또는 내림차순 -> 2/n!)

</p>
</details>

<details>
<summary>퀵소트에서 최악의 경우 시간복잡도를 개선시킬 수 있는 방법이 있을까요?</summary>
<p>

피벗의 위치를 다르게 설정함으로써 시간복잡도를 개선시킬 수 있습니다. 일정한 위치에 대해서만(ex. 첫번째 element) 피벗을 설정하는 것보다 첫번째, 마지막 element 중 무작위로 선택한다거나 첫번째, 가운데, 마지막 element 중 중간값을 계산하여 피벗을 설정했을 때 시간복잡도를 더 개선시킬 수 있습니다.

</p>
</details>

<details>
<summary>머지소트의 분할 정복 과정에 대해 단계별로 설명해주세요.</summary>
<p>

- Divide : 초기 배열을 2개의 배열로 분할
- Conquer : 각 부분 배열을 정렬
- Combine : 부분 배열을 하나의 배열로 결합

</p>
</details>

---

<!-- MST -->

<details>
<summary>MST(Minimum Spanning Tree)를 구하는 알고리즘에 대해 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 설명해 주세요.</summary>
<p>

> 정점의 개수 : V, 간선의 개수 : E

대표적으로 프림 알고리즘과 크루스칼 알고리즘이 있습니다. 프림 알고리즘은 정점을 선택하고 그것과 연결된 가장 적은 비용의 정점을 선택하는 방식이며, O(ElogV)의 시간복잡도를 가집니다. 크루스칼 알고리즘은 모든 간선에 대하여 가장 비용이 적은 간선을 선택하는 방식이며 O(ElogE)의 시간복잡도를 가집니다. 프림 알고리즘은 정점의 개수에 비해 간선이 많이 주어진 경우 사용하는 것이 좋고, 크루스칼 알고리즘은 간선의 개수에 비해 정점이 많이 주어진 경우 사용하는 것이 좋습니다.

</p>
</details>

---

<!-- 최단 경로 -->

<details>
<summary>최단경로를 구하기 위한 알고리즘을 두 가지 이상 말하고 어떤 차이점이 있는지 설명해주세요.</summary>
<p>

- 다익스트라 : 하나의 시작 정점 ~ 모든 다른 정점까지의 최단 경로를 구한다.
- 벨만포드 : 하나의 시작 정점 ~ 모든 다른 정점까지의 최단 경로를 구한다. + 가중치가 음수일 때도 사용이 가능하다. (음의 사이클 검사 가능)
- 플로이드 와샬 : 모든 정점 ~ 모든 정점까지의 최단 경로를 구한다.

</p>
</details>

<details>
<summary>다익스트라 알고리즘 동작원리 또는 특징을 시간복잡도와 연관지어 설명해주세요.</summary>
<p>

(방법 1)
1. 출발 노드 S에서 모든 노드들까지의 최단 거리를 저장하는 배열 D를 초기화한다.
2. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다. (D 배열 검사)
3. 선택한 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 배열 D를 갱신한다.
4. 모든 노드를 방문할 때까지 3, 4 과정을 반복한다.
5. 노드의 개수를 V라고 할 때, 총 V*V번 연산이 필요하므로 `O(V^2)`의 시간복잡도를 가진다.

(방법 2 - 힙/우선순위큐 사용)
1. 출발 노드 S에 대하여 D 배열을 초기화할 때 D[S] = 0을 해준다. 이와 동시에 힙에 노드 정보(번호, 거리 : [S, 0])를 넣어준다.
2. 힙에서 맨 위에 있는 노드 I를 꺼낸다.
3. 만일 꺼낸 노드 I의 거리 정보가 현재 D[I]보다 크다면 이미 방문한 노드일 것이므로 무시한다.
4. I를 대상으로 다익스트라 알고리즘을 수행하는데, D 배열이 갱신될 경우 그 노드 정보를 힙에 넣는다.
5. 힙에 노드가 없을 때까지 2-4 과정을 반복한다.
6. 노드의 개수를 V, 간선의 개수를 E라고 할 때 시간 복잡도는 `O(ElogV)` 이다.

</p>
</details>

<details>
<summary>다익스트라 알고리즘에서 힙(우선순위큐)을 사용할 경우 어떤 점에서 시간복잡도가 개선이 되나요?</summary>
<p>

다익스트라 알고리즘에서 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택하는 과정이 있는데, 이 과정에서 O(`노드의 개수`)만큼의 비용이 발생하게 됩니다. 힙(우선순위큐)을 사용할 경우 그 비용을 O(`log{힙에 저장한 노드의 개수}`)로 줄일 수 있습니다.

</p>
</details>
